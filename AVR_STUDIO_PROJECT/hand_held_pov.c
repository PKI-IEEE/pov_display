// Author: Josh Hansen
// Date: May 2014
// Description: Hand-waved persistence of vision display. The display uses an analogue accelerometer to 
// detect when it is moving in a particular direction. Enter desired message into 
// message1 and message2 arrays. Also update numCharFirstMessage and numCharSecondMessage 
// with the number of characters in each respective message. The display is limited to 6 character
// messages. It is difficult to wave the display fast enough to display more than 6 characters and
// the way the timing is set in this program, a word with more than 6 characters can get cut off.

// Improvements that could be made include: 
// 1. Adjusting the delay between columns according to how fast the display is being waved (timing the wave)
// 2. Finishing the ASCII array to include all symbols
// 3. Adding a feature where if the display is moved rapidly along the Y or Z axis the message is changed (both Y and Z outputs of the accelerometer are connected to ADC)
//#define F_CPU 16000000 // comment this out if using AVR Studio 4
#include <avr/io.h>
#include <util/delay.h>

/*------------------------------------------CHANGE MESSAGE BELOW---------------------------------------*/
volatile uint8_t message1[] = {"Hello"};
#define numCharFirstMessage 5
volatile uint8_t message2[] = {"IEEE!"};
#define numCharSecondMessage 5
/*------------------------------------------CHANGE MESSAGE ABOVE---------------------------------------*/

#define LED_PORT PORTD // LEDs are on PORT D
#define ACCEL_PORT PORTC // ADC from accelerometer on PORT C
volatile uint8_t currentMessageLength =  numCharFirstMessage;
volatile uint8_t *message = message1; //holds the current message

// ASCII Array. Not all symbols are completed. All letters, both upper and lower case,
// are in the table as well as all numbers 0-9 but not all have been tested.
// Many of the other symbols have not been done. If there is all 0's it's not done.
// Each character is basically created in a 5x8 dot matrix. 
// @ = 1 char sized smiley face
// [] = 2 char sized smiley face
unsigned char letterArray[] = {
0x00,0x00,0x00,0x00,0x00, // space 0
0x00,0x00,0xBE,0x00,0x00, // ! 1
0x00,0x0E,0x00,0x0E,0x00, // " 2
0x28,0xFE,0x28,0xFE,0x28, // # 3
0x48,0x54,0xFE,0x54,0x24, // $ 4
0x46,0x26,0x10,0xC8,0xC4, // % 5
0x6C,0x92,0xAA,0x44,0xA0, // & 6
0x00,0x00,0x00,0x00,0x00, // ' 7
0x00,0x00,0x00,0x00,0x00, // ( 8
0x00,0x00,0x00,0x00,0x00, // ) 9 
0x00,0x00,0x00,0x00,0x00, // * 10
0x00,0x00,0x00,0x00,0x00, // + 11
0x00,0x00,0x00,0x00,0x00, // , 12
0x00,0x00,0x00,0x00,0x00, // - 13
0x00,0x00,0x00,0x00,0x00, // . 14
0x00,0x00,0x00,0x00,0x00, // / 15
0x7C,0xA2,0x92,0x8A,0x7C, // 0 16
0x00,0x84,0xFE,0x80,0x00, // 1 17
0x84,0xC2,0xA2,0x92,0x8C, // 2 18
0x42,0x82,0x8A,0x96,0x62, // 3 19
0x30,0x28,0x24,0xFE,0x20, // 4 20
0x4E,0x8A,0x8A,0x8A,0x72, // 5 21
0x78,0x94,0x92,0x92,0x60, // 6 22
0x02,0xF2,0x0A,0x0A,0x06, // 7 23
0x6C,0x92,0x92,0x92,0x6C, // 8 24
0x0C,0x92,0x92,0x52,0x3C, // 9 25
0x00,0x00,0x00,0x00,0x00, // : 26
0x00,0x00,0x00,0x00,0x00, // ; 27
0x00,0x00,0x00,0x00,0x00, // < 28
0x00,0x00,0x00,0x00,0x00, // = 29
0x00,0x00,0x00,0x00,0x00, // > 30
0x00,0x00,0x00,0x00,0x00, // ? 31
0x20,0x44,0x40,0x44,0x20, // @ 32 
0xFE,0x11,0x11,0x11,0xFE, // A 33
0xFF,0x99,0x99,0x99,0x66, // B 34
0xFF,0x81,0x81,0x81,0x81, // C 35
0xFF,0x81,0x81,0xC3,0x7E, // D 36
0xFF,0x99,0x99,0x99,0x81, // E 37
0xFF,0x09,0x09,0x09,0x01, // F 38
0x7E,0x81,0x91,0x91,0x72, // G 39
0xFF,0x18,0x18,0x18,0xFF, // H 40
0x81,0x81,0xFF,0x81,0x81, // I 41
0x40,0x80,0x80,0x80,0x7F, // J 42
0xFF,0x18,0x24,0x42,0x81, // K 43
0xFF,0x80,0x80,0x80,0x80, // L 44
0xFF,0x02,0x0C,0x02,0xFF, // M 45 
0xFF,0x06,0x18,0x60,0xFF, // N 46
0x7E,0x81,0x81,0x81,0x7E, // O 47
0xFF,0x09,0x09,0x09,0x06, // P 48
0x7E,0x81,0xA1,0x41,0xBE, // Q 49
0xFF,0x09,0x19,0x29,0xC6, // R 50
0x46,0x89,0x91,0x91,0x62, // S 51
0x01,0x01,0xFF,0x01,0x01, // T 52
0x7F,0x80,0x80,0x80,0x7F, // U 53
0x3F,0x40,0x80,0x40,0x3F, // V 54
0x7F,0x80,0x70,0x80,0x7F, // W 55
0x63,0x14,0x08,0x14,0x63, // X 56
0x07,0x08,0xF8,0x08,0x07, // Y 57
0x61,0x51,0x49,0x45,0x43, // Z 58
0x00,0x10,0x20,0x43,0x40, // [ 59
0x00,0x00,0x00,0x00,0x00, // \ 60
0x40,0x43,0x20,0x10,0x00, // ] 61
0x00,0x00,0x00,0x00,0x00, // ^ 62
0x00,0x00,0x00,0x00,0x00, // _ 63
0x00,0x00,0x00,0x00,0x00, // `
0x40,0xA8,0xA8,0xA8,0xF0, // a 64
0xFE,0xA0,0x90,0x90,0x60, // b 65
0x70,0x88,0x88,0x88,0x40, // c 66
0x60,0x90,0x90,0xA0,0xFE, // d 67
0x70,0xA8,0xA8,0xA8,0x30, // e 68
0x08,0xFC,0x0A,0x02,0x04, // f 69
0x18,0xA4,0xA4,0xA4,0x7C, // g 70
0xFE,0x10,0x08,0x08,0xF0, // h 71
0x00,0x00,0xF4,0x00,0x00, // i 72
0x40,0x80,0x80,0x7A,0x00, // j 73
0xFE,0x20,0x50,0x88,0x00, // k 74
0x00,0x82,0xFE,0x80,0x00, // l 75
0xF8,0x08,0x30,0x08,0xF0, // m 76
0xF8,0x10,0x08,0x08,0xF0, // n 77
0x70,0x88,0x88,0x88,0x70, // o 78
0xF8,0x28,0x28,0x28,0x10, // p 79
0x10,0x28,0x28,0x30,0xF8, // q 80
0xF8,0x10,0x08,0x08,0x10, // r 81
0x90,0xA8,0xA8,0xA8,0x40, // s 82
0x00,0x08,0x7E,0x88,0x40, // t 83
0x78,0x80,0x80,0x40,0xF8, // u 84
0x38,0x40,0x80,0x40,0x38, // v 85
0x78,0x80,0x60,0x80,0x78, // w 86
0x88,0x50,0x20,0x50,0x88, // x 87
0x18,0xA0,0xA0,0xA0,0x78, // y 88
0x88,0xC8,0xA8,0x98,0x88  // z 89					
};

void adcInit(void);
void displayInit(void);
void delay(void);
void displayFWD(unsigned char letterIn);

void adcInit() {

	DDRC = 0; // ADC port input
	ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); // ADC Enable, ADC prescaler /128
}

void displayInit() {
	DDRD = 0xFF; // LED's as outputs
	LED_PORT = 0xFF; // turn all LED's off to start
	TCCR1B |= (1<<CS12) | (1<<CS10); // /1024 prescaler 64us tick
}

void delay(void) {
	TCNT0 = 190; // 3.056ms
	TCCR0B |= (1<<CS02); // /256 prescaler 1 tick every 16us
	while((TIFR0 & (1<<TOV0)) == 0);
	TCCR0B = 0;
	TIFR0 |= (1<<TOV0);
}

void displayFWD(unsigned char letterIn) {

	for(uint8_t i=0;i<5;i++) {
		LED_PORT = ~(letterArray[((letterIn - 0x20) * 5) + i]); // put the column of the current letter out to the LEDs
		delay(); // delay while on
		LED_PORT = 0xFF; // turn LEDs off
		delay(); // delay while off
	
	}
	delay();
	delay(); // puts a space between each column
}

int main(void) {
	unsigned int newAccel = 550; // accelerometer reading from ADC (0-1023)
	unsigned int accelReadingHigh = 0; // high byte from ADC
	unsigned int accelReadingLow = 0; // low byte from ADC
	uint8_t swipe = 0;

	displayInit();
	adcInit();

	while(1) {
		
		ADCSRA |= (1<<ADSC); // start ADC conversion
		while((ADCSRA & (1<<ADIF))==0); // wait for ADC conversion 
		accelReadingLow = ADCL; // get ADC low value
		accelReadingHigh = ADCH; // get ADC high value
		newAccel = ((accelReadingHigh << 8) | (accelReadingLow));// combine ADC value

		if(newAccel > 1000 && swipe <= 1  ) { // if there is high acceleration in one direction
		
			if(TCNT1 < 31250) {	 // one second between messages
				message = message1;
				currentMessageLength = numCharFirstMessage;
			}
			else {
				message = message2;
				currentMessageLength = numCharSecondMessage;
			}
			_delay_ms(60); // wait before message start
				
			for(uint8_t i=0;i<currentMessageLength;i++) { // push out the message
				displayFWD(message[i]);
			}
			LED_PORT = 0xFF; // turn LEDs off
			delay(); 
			delay(); // puts some space between each letter
		}
		else if(newAccel < 50) { // acceleration in one direction leads to deceleration in the other direction
			swipe++; 
		}
	// Every swipe across and then back causes acceleration in the one direction to be registered twice. 	
		if(swipe >= 2) { 
			swipe = 0;
		}
	} // end while
} // end main
